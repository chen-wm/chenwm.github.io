(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{330:function(e,t,v){"use strict";v.r(t);var a=v(4),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[t("img",{attrs:{src:"https://img2.baidu.com/it/u=1037982662,1163128321&fm=253&fmt=auto&app=138&f=JPG?w=1846&h=500",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[e._v("#")]),e._v(" "),t("code",[e._v("概念")])]),e._v(" "),t("p",[e._v("vue组件实例化顺序为：父组件状态初始化(data、computed、watch...) --\x3e 模板编译 --\x3e "),t("code",[e._v("生成render方法")]),e._v(" --\x3e 实例化渲染watcher --\x3e "),t("code",[e._v("调用render方法，生成VNode")]),e._v(" --\x3e patch VNode，转换为真实DOM --\x3e 实例化子组件 --\x3e ......重复相同的流程 --\x3e 子组件生成的真实DOM挂载到父组件生成的真实DOM上，挂载到页面中 --\x3e 移除旧节点")]),e._v(" "),t("p",[e._v("从上述流程中，可以推测出：")]),e._v(" "),t("ul",[t("li",[e._v("父组件模板解析在子组件之前，所以父组件首先会获取到插槽模板内容")]),e._v(" "),t("li",[e._v("子组件模板解析在后，所以在子组件调用render方法生成VNode时，可以借助部分手段，拿到插槽的VNode节点")]),e._v(" "),t("li",[e._v("作用域插槽可以获取子组件内变量，因此作用域插槽的VNode生成，是动态的，即需要实时传入子组件的作用域scope")])]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("整个插槽的处理阶段大致分为三步：")]),e._v(" "),t("ul",[t("li",[e._v("编译")]),e._v(" "),t("li",[e._v("生成渲染模板")]),e._v(" "),t("li",[e._v("生成VNode")])]),e._v(" "),t("h3",{attrs:{id:"不同slot在v2-5、v2-6中编译区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不同slot在v2-5、v2-6中编译区别"}},[e._v("#")]),e._v(" "),t("code",[e._v("不同slot在v2.5、v2.6中编译区别")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47344e6c005a49dfae772301749b0e84~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"默认插槽"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认插槽"}},[e._v("#")]),e._v(" "),t("code",[e._v("默认插槽")])]),e._v(" "),t("p",[e._v("在两个版本中的写法,都是在 父组件中生成 vNode。vNode 存在 vm.$slot 中。待子组件 render 到插槽时，会直接拿到 父组件的 vNode")]),e._v(" "),t("h4",{attrs:{id:"作用域插槽"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域插槽"}},[e._v("#")]),e._v(" "),t("code",[e._v("作用域插槽")])]),e._v(" "),t("p",[t("code",[e._v("v2.5版本")]),e._v(" 跟默认插槽是一样的，在父组件生成vNode，子组件直接拿来用\n"),t("br"),e._v(" "),t("code",[e._v("v2.6版本")]),e._v(" 在 子组件 中才去执行 插槽render ，生成 插槽vNode")]),e._v(" "),t("h4",{attrs:{id:"具名插槽"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具名插槽"}},[e._v("#")]),e._v(" "),t("code",[e._v("具名插槽")])]),e._v(" "),t("p",[e._v("不管版本，都是在子组件中进行render的")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("具名插槽可以在父组件中获取子组件数据原因")]),e._v(" "),t("p",[e._v("作用域插槽只有子组件render的时候，才会执行render生成vNode。并且，作用域插槽的 render 函数能接参数，从而获得子组件的数据。就是这样形成了作用域插槽！所以我们能在父组件中，访问到子组件的data数据")])])])}),[],!1,null,null,null);t.default=r.exports}}]);