(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{326:function(_,e,v){"use strict";v.r(e);var t=v(4),o=Object(t.a)({},(function(){var _=this,e=_._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h3",{attrs:{id:"问题-1-浏览器是如何渲染-ui-的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题-1-浏览器是如何渲染-ui-的"}},[_._v("#")]),_._v(" "),e("code",[_._v("问题 1：浏览器是如何渲染 UI 的？")])]),_._v(" "),e("h4",{attrs:{id:"浏览器是如何渲染ui的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器是如何渲染ui的"}},[_._v("#")]),_._v(" "),e("code",[_._v("浏览器是如何渲染UI的？")])]),_._v(" "),e("ol",[e("li",[e("p",[_._v("浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree")])]),_._v(" "),e("li",[e("p",[_._v("与此同时，进行CSS解析，生成Style Rules")])]),_._v(" "),e("li",[e("p",[_._v("接着将DOM Tree与Style Rules合成为 Render Tree")])]),_._v(" "),e("li",[e("p",[_._v("接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标")])]),_._v(" "),e("li",[e("p",[_._v("随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来")])])]),_._v(" "),e("h4",{attrs:{id:"dom-tree是如何构建的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dom-tree是如何构建的"}},[_._v("#")]),_._v(" "),e("code",[_._v("DOM Tree是如何构建的？")])]),_._v(" "),e("p",[_._v("1、转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串")]),_._v(" "),e("p",[_._v("2、生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens")]),_._v(" "),e("p",[_._v("3、构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope")]),_._v(" "),e("p",[_._v("4、生成DOM Tree: 通过node包含的指针确定的关系构建出DOM")]),_._v(" "),e("h3",{attrs:{id:"问题-2-web-攻击"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题-2-web-攻击"}},[_._v("#")]),_._v(" "),e("code",[_._v("问题 2：WEB 攻击")])]),_._v(" "),e("p",[e("code",[_._v("XSS")]),_._v("(跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当用户登陆网站时就会执行这些恶意代码，这些脚本可以读取"),e("code",[_._v("cookie，session tokens")]),_._v("，或者其它敏感的网站信息")]),_._v(" "),e("p",[e("code",[_._v("CSRF")]),_._v("（跨站请求伪造：攻击者诱导用户进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用用户在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。")]),_._v(" "),e("p",[e("code",[_._v("Sql")]),_._v("注入攻击，是通过将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行进行的攻击")]),_._v(" "),e("h4",{attrs:{id:"xss避免方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#xss避免方式"}},[_._v("#")]),_._v(" "),e("code",[_._v("XSS避免方式：")])]),_._v(" "),e("p",[_._v("1、"),e("code",[_._v("url")]),_._v("参数使用"),e("code",[_._v("encodeURIComponent")]),_._v("方法转义")]),_._v(" "),e("p",[_._v("2、尽量不是有InnerHtml插入HTML内容")]),_._v(" "),e("p",[_._v("3、使用特殊符号、标签转义符。")]),_._v(" "),e("p",[e("code",[_._v("CSRF")]),_._v("避免方式：")]),_._v(" "),e("p",[_._v("1、添加验证码")]),_._v(" "),e("p",[_._v("2、使用token")]),_._v(" "),e("p",[_._v("服务端给用户生成一个token，加密后传递给用户\n用户在提交请求时，需要携带这个token\n服务端验证token是否正确\nDDoS又叫分布式拒绝服务，其原理就是利用大量的请求造成资源过载，导致服务不可用。")]),_._v(" "),e("h4",{attrs:{id:"ddos-避免方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ddos-避免方式"}},[_._v("#")]),_._v(" "),e("code",[_._v("DDos 避免方式：")])]),_._v(" "),e("p",[_._v("1、限制单IP请求频率。")]),_._v(" "),e("p",[_._v("2、防火墙等防护设置禁止ICMP包等")]),_._v(" "),e("p",[_._v("3、检查特权端口的开放")]),_._v(" "),e("h3",{attrs:{id:"问题-3-如何理解-cdn-实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题-3-如何理解-cdn-实现原理"}},[_._v("#")]),_._v(" "),e("code",[_._v("问题 3：如何理解 CDN？实现原理？")])]),_._v(" "),e("p",[_._v("内容分发网络：\n构建在现有网络基础之上的智能虚拟网络，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。")]),_._v(" "),e("p",[_._v("CDN 的关键技术主要有内容存储和分发技术。简单来讲，CDN就是根据用户位置分配最近的资源。")]),_._v(" "),e("p",[_._v("应用CDN后，DNS 返回的不再是 IP 地址，而是一个CNAME(Canonical Name ) 别名记录，指向CDN的全局负载均衡。")]),_._v(" "),e("p",[_._v("CNAME实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是CDN实现的关键。")]),_._v(" "),e("h3",{attrs:{id:"问题-5-什么是原型-什么是原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题-5-什么是原型-什么是原型链"}},[_._v("#")]),_._v(" "),e("code",[_._v("问题 5：什么是原型 ? 什么是原型链 ？")])]),_._v(" "),e("p",[_._v("JavaScript 一种基于原型的语言——每个函数对象都有一个 prototype 属性，这个属性指向函数的原型对象。\n原型关系：")]),_._v(" "),e("p",[_._v("每个 class都有显示原型 prototype\n每个实例都有隐式原型 proto\n实例的 proto 指向对应 class 的 prototype\n当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。")]),_._v(" "),e("p",[_._v("原型链：函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针 proto, 该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而 Object 原型对象用 Object.prototype.__ proto__ = null 表示原型链顶端。如此形成了js的原型链继承。")]),_._v(" "),e("p",[e("code",[_._v("特点:  JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。")])])])}),[],!1,null,null,null);e.default=o.exports}}]);